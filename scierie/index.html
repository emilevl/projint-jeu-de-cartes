<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Making your first Phaser 3 Game - Part 10</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <script src="scripts/joy.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Limelight&display=swap" rel="stylesheet">
    <style type="text/css">
        body {
            margin: 0;
        }
        h1 {
            position: absolute;
            left: 1rem;
            font-family: 'Limelight', cursive;
        }
    </style>
</head>
<body>

    <h1 id="chrono">00'00</h1>

    <div id="joy1Div" style="width:200px;height:200px;position:absolute;bottom:0px;left:0px;z-index:100;"></div>

<script type="text/javascript">
    
    // Create JoyStick object into the DIV 'joy1Div'
    let Joy1 = new JoyStick('joy1Div', {})
    
</script>

<script type="text/javascript">

    let joyStick = document.getElementById('joy1Div');

let config = {
    type: Phaser.AUTO,
    width: window.innerWidth,
    height: window.innerHeight,
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 1000 },
            debug: true
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

let chronoH1 = document.getElementById('chrono');


const spawnPoint = {x: 400, y: 0};


let deathCount = 0;
let chrono = 0;
let timer;

let player;

let triangle;
let graphics;

let cursors;
let bigSaw

const bigSawSpeed = 10;

let timeJumping = 500;
let timeStart = 0;
const jumpingTime = 400;
const playerVelocity = 400;


let game = new Phaser.Game(config);

function preload ()
{
    // load the PNG file
	this.load.image('base_tiles', 'assets/tiles/tiles.png')

    // load the JSON file
    this.load.tilemapTiledJSON('tilemap', 'assets/tiles/map.json')

    // Load Player asset
    this.load.spritesheet('player', 'assets/player.png', { frameWidth: 68.2, frameHeight: 58 });

    // Load log asset
    this.load.image('log', 'assets/log.png');

    // Load big saw asset
    this.load.image('bigSaw', 'assets/bigSaw.png');
}

function create ()
{   
    
    this.cameras.main.setBounds(0, 0, 4000, 100);
    this.physics.world.setBounds(0, 0, 4000, 400);

    // Touch input show the joystick
    /*
    this.input.on('pointerdown', function (pointer) {
        //console.log(pointer);
        joyStick.style.left = pointer.x-150 + "px";
        joyStick.style.top = pointer.y-150 + "px";
        console.log(Joy1);
    });
    */

    // create the Tilemap
	const map = this.make.tilemap({ key: 'tilemap' })

    // add the tileset image we are using
    const tileset = map.addTilesetImage('tiles-basic', 'base_tiles');
    
    let bg = map.createDynamicLayer('bg', tileset);

    // "Platform" layer will be on top of "Background" layer
    let platform = map.createDynamicLayer('platform', tileset);
    platform.setCollisionByExclusion(-1, true);

    let saw = map.createDynamicLayer('saw', tileset);
    

    // The player and its settings
    player = this.physics.add.sprite(spawnPoint.x, spawnPoint.y, 'player').setCollideWorldBounds(true).setBounce(0);


    graphics = this.add.graphics({ lineStyle: { width: 2, color: 0x00ff00 } });
    

    //  Our player animations, turning, walking left and walking right.
    this.anims.create({
        key: 'left',
        frames: [ { key: 'player', frame: 4 } ],
        frameRate: 10
    });

    this.anims.create({
        key: 'turn',
        frames: [ { key: 'player', frame: 2 } ],
        frameRate: 20
    });

    this.anims.create({
        key: 'right',
        frames: [ { key: 'player', frame: 0 } ],
        frameRate: 10,
    });

    //  Input Events
    cursors = this.input.keyboard.createCursorKeys();

    //  Collide the player
    this.physics.add.collider(platform, player);

    // Death on saw touch
    saw.setCollisionByExclusion([-1])
    this.physics.add.collider(player, saw, hitSaws, null, this);

    // Logs
    logs = this.physics.add.group();
    this.physics.add.collider(logs, platform);
    this.physics.add.collider(player, logs, hitLogs, null, this);

    // Add a log
    let log = logs.create(player.x + 200, player.y - 10000, 'log').setScale(0.07);
    log.setBounce(0.3);
    log.setCollideWorldBounds(true);

    // Big saw
    bigSaw = this.physics.add.sprite(0, 360, "bigSaw").setScale(0.5);
    bigSaw.body.setAllowGravity(false)
    bigSaw.body.isCircle = true;
    bigSaw.setGravity(0).setImmovable(true).setVelocityX(bigSawSpeed)

    this.physics.add.collider(player, bigSaw, hitSaws, null, this);

    // Camera
    this.cameras.main.setBounds(0, 0, bg.displayWidth, bg.displayHeight);
    this.cameras.main.startFollow(player);

    //deathCountText = this.add.text(16, 16, 'death: ' + deathCount, { fontSize: '32px', fill: '#000' });

    timer = this.time.addEvent({
          delay: 1000,
          callback: addSecond,
          callbackScope: this,
          loop: true
    });

}

function update ()
{   
    // Rotate the big saw
    bigSaw.rotation += 0.05

    graphics.clear();
    triangle = new Phaser.Geom.Triangle.BuildEquilateral(player.x, player.y-player.height/2, player.width);
    graphics.strokeTriangleShape(triangle);


    if (cursors.left.isDown)
    {
        player.setVelocityX(-playerVelocity);
        player.anims.play('left', true);
    }
    else if (cursors.right.isDown)
    {
        player.setVelocityX(playerVelocity);
        player.anims.play('right', true);
    }
    else
    {
        player.setVelocityX(0);
        player.anims.play('turn');
    }

    // Jump
    if (cursors.space.isDown)
    {   
        if (player.body.blocked.down) {
            timeStart = this.time.now;
        }
        
        if (player.body.blocked.down || this.time.now < timeStart + timeJumping) {
            player.setVelocityY(-playerVelocity);
        }
    }


    if (this.input.activePointer.isDown) {
        
        if (this.input.activePointer.isDown) {
            if (player.body.blocked.down) {
            timeStart = this.time.now;
        }
        
        if (player.body.blocked.down || this.time.now < timeStart + timeJumping) {
            player.setVelocityY(-playerVelocity);
        }
        }
    }
    

    
    setInterval(function(){ player.setVelocityX(Joy1.GetX()/80*playerVelocity); }, 50);
    player.setVelocityX(Joy1.GetX())
    

    
    
}


function addSecond() {
    chrono++;

    chronoH1.innerHTML = formatTime(chrono);
}

function formatTime(time) {
    
    let minutes = Math.floor(time / 60);

    // 👇️ get the remainder of the seconds
    let seconds = time % 60;
    let formatedTime = minutes.toString().padStart(2, '0') + "'" + seconds.toString().padStart(2, '0');
    return formatedTime;
}


function hitLogs (player, log)
{
    this.physics.pause();

    deathCount++;
    //deathCountText.setText('Death: ' + deathCount);
    
    player.setPosition(spawnPoint.x, spawnPoint.y);
    log.destroy();
    
    this.physics.resume();
    
}

function hitSaws(player, saw)
{
    this.physics.pause();

    deathCount++;
    //deathCountText.setText('Death: ' + deathCount);

    player.setPosition(spawnPoint.x, spawnPoint.y);
    bigSaw.x = 0

    this.physics.resume();

}

</script>



</body>
</html>